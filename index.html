<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Motion Tracker (YOLO ONNX)</title>
  <style>

:root{ --bg:#0f1724; --card:#0b1220; --accent:#0ea5ff; --text:#e6eef8; }
*{ box-sizing:border-box; }
html,body{ height:100%; margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif; background:linear-gradient(180deg,#071024,#0b1522); color:var(--text); }
.app{ max-width:1100px; margin:12px auto; padding:12px; }
header h1{ margin:0; font-size:1.4rem; }
.subtitle{ margin:4px 0 12px; color:#bcd7f7; }
.controls{ background:rgba(255,255,255,0.03); padding:10px; border-radius:10px; margin-bottom:12px; }
.row{ display:flex; gap:8px; flex-wrap:wrap; }
.row.small{ margin-top:8px; font-size:0.9rem; }
.file-btn{ background:var(--card); padding:8px 10px; border-radius:8px; cursor:pointer; }
.file-btn input{ display:none; }
button{ background:var(--accent); border:0; color:#04233a; padding:8px 10px; border-radius:8px; cursor:pointer; }
.workspace{ display:flex; gap:12px; align-items:flex-start; }
.video-wrap{ position:relative; flex:1; min-width:260px; border-radius:8px; overflow:hidden; background:#000; }
.video-wrap > video, .video-wrap > img, .video-wrap > canvas{ position:absolute; left:0; top:0; width:100%; height:100%; display:block; }
video{ width:100%; height:100%; display:block; z-index:1; }
img#framePreview{ z-index:2; pointer-events:none; object-fit:contain; }
canvas#overlay{ position:absolute; left:0; top:0; touch-action:none; z-index:3; pointer-events:auto; }
.analysis{ width:320px; background:rgba(255,255,255,0.03); padding:10px; border-radius:8px; }
#charts canvas{ width:100% !important; height:200px; }
footer{ margin-top:12px; color:#9fb7d9; }
.frame-canvas{ width:100%; height:auto; display:block; border:1px solid rgba(255,255,255,0.04); }
.controls .hint{ margin-top:6px; }
@media (max-width:800px){ .workspace{ flex-direction:column; } .analysis{ width:100%; } }
.hint{ font-size:0.9rem; color:#a9c6e9; }
.tabs{ display:flex; gap:6px; margin-bottom:10px; }
.tab{ background:rgba(255,255,255,0.03); padding:8px 10px; border-radius:8px; cursor:pointer; }
.tab.active{ background:linear-gradient(90deg,#06b6d4,#4fd1c5); color:#002733; }
.tab-content{ padding:8px; background:rgba(255,255,255,0.02); border-radius:8px; }
.big{ background:#06b6d4; color:#002733; padding:10px 12px; border-radius:8px; font-weight:600; }
.frame-nav button{ padding:6px 10px; }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <h1>Motion Tracker (YOLO ONNX)</h1>
      <div class="subtitle">동영상에서 물체를 지정해 운동을 분석합니다. (모바일 지원)</div>
      <div id="status">모델 로드 상태: 대기 중...</div>
      <div class="tabs">
        <button id="stepCamera" class="tab active">촬영/업로드</button>
        <button id="stepExtract" class="tab">프레임 추출</button>
        <button id="stepROI" class="tab">ROI 선택</button>
        <button id="stepAnalyze" class="tab">분석/결과</button>
      </div>
    </header>
    <section id="tab-1" class="tab-content">
      <div class="controls">
        <div class="row">
          <label class="file-btn">
            <input type="file" id="videoFile" accept="video/*" />
            비디오 업로드
          </label>
          <button id="startCamera">카메라 켜기</button>
          <button id="recordToggle" style="display:none;" disabled>녹화 시작</button>
        </div>
        <div class="hint">카메라로 촬영하거나 비디오 파일을 업로드하세요.</div>
      </div>
      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>
        <aside class="analysis">
          <div class="big">스케일(픽셀→단위)</div>
          <div class="row small">
            <label>픽셀/단위: <input id="scaleInput" type="number" min="0.0001" step="0.0001" value="100" /></label>
          </div>
          <div id="charts">
            <canvas id="posChart"></canvas>
            <canvas id="velChart"></canvas>
          </div>
        </aside>
      </div>
    </section>
    <section id="tab-2" class="tab-content" style="display:none;">
      <div class="controls">
        <div class="row">
          <label>FPS: <input id="fpsInput" type="number" min="1" step="1" value="10" /></label>
          <button id="extractFramesBtn" disabled>프레임 추출 시작</button>
        </div>
        <div id="extractProgress" class="row small" style="display:none;">
          <div style="flex:1;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;">
            <div id="progressBar" style="width:0%;height:8px;background:#0ea5ff;"></div>
          </div>
          <div id="progressText">0%</div>
        </div>
        <div class="frame-nav" style="display:none;gap:8px;align-items:center;margin-top:8px;">
          <button id="prevFrame">◀</button>
          <span id="frameIdx">Frame 0 / 0</span>
          <button id="nextFrame">▶</button>
        </div>
        <div class="hint">추출된 프레임은 상단 영상 영역에 이미지로 표시됩니다.</div>
      </div>
      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>
        <aside class="analysis">
          <div class="hint">프레임을 확인하고 다음 탭에서 ROI를 지정하세요.</div>
        </aside>
      </div>
    </section>
    <section id="tab-3" class="tab-content" style="display:none;">
      <div class="controls">
        <div class="big">이 프레임 ROI 선택</div>
        <div class="hint">오버레이 캔버스에서 드래그하여 ROI(관심 영역)를 그리면 자동 저장됩니다. 프레임별로 반복하세요.</div>
        <div class="row">
          <button id="completeROIs">ROI 선택 완료 (자동 분석 실행)</button>
        </div>
      </div>
      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>
        <aside class="analysis">
          <div class="hint">ROI가 있는 프레임은 해당 영역을, 없는 프레임은 YOLO로 자동 지정됩니다.</div>
        </aside>
      </div>
    </section>
    <section id="tab-4" class="tab-content" style="display:none;">
      <div class="controls">
        <div class="row">
          <label>신뢰도(0~1): <input id="confInput" type="number" min="0" max="1" step="0.01" value="0.3" /></label>
          <button id="runDetectBtn">자동 분석</button>
          <button id="playResultsBtn">결과 재생</button>
          <button id="exportCSV">CSV 내보내기</button>
        </div>
        <div class="hint">분석을 실행하면 그래프가 갱신되고 오버레이에 박스가 그려집니다.</div>
      </div>
      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>
        <aside class="analysis">
          <div id="charts">
            <canvas id="posChart"></canvas>
            <canvas id="velChart"></canvas>
          </div>
        </aside>
      </div>
    </section>
    <footer>모델 파일(<code>yolov8n.onnx</code>)을 프로젝트 루트 또는 <code>./model/</code>에 두세요.</footer>
  </div>
  <script>

const $ = (id) => document.getElementById(id);
const video = document.querySelector('.video-wrap > video');
const overlay = $('overlay');
const framePreview = $('framePreview');
let modelSession = null; let modelLoaded = false; let detectionsPerFrame = []; let frameROIs = []; let roi = null; let posChart=null, velChart=null; let scalePxPerUnit = 100; let lastNavTime = 0;
const numOr = (v, def) => { const n = Number(v); return Number.isFinite(n) ? n : def; };
function userLog(msg){ console.log('[Traker]', msg); }
if (video){ try{ video.playsInline=true; video.muted=true; video.controls=true; video.style.display='block'; }catch{} }
if (video){ video.addEventListener('loadeddata', ()=>{ resizeOverlay(); }); }
const videoFile=$('videoFile'), startCameraBtn=$('startCamera'), recordToggleBtn=$('recordToggle'), extractFramesBtn=$('extractFramesBtn'), prevFrameBtn=$('prevFrame'), nextFrameBtn=$('nextFrame'), frameIdxEl=$('frameIdx'), extractProgress=$('extractProgress'), progressBar=$('progressBar'), progressText=$('progressText');
const stepCamera=$('stepCamera'), stepExtract=$('stepExtract'), stepROI=$('stepROI'), stepAnalyzeBtn=$('stepAnalyze');
const runDetectBtn=$('runDetectBtn'), completeROIsBtn=$('completeROIs'), playResultsBtn=$('playResultsBtn'), exportCSVBtn=$('exportCSV');
const fpsInput=$('fpsInput'), confInput=$('confInput'), scaleInput=$('scaleInput');
function switchTab(n){ try{ [1,2,3,4].forEach(i=>{ const panel=$(`tab-${i}`); const btn=document.getElementById('step'+(i===1?'Camera':(i===2?'Extract':(i===3?'ROI':'Analyze')))); if(panel) panel.style.display=(i===n)?'':'none'; if(btn){ if(i===n) btn.classList.add('active'); else btn.classList.remove('active'); } }); }catch(e){} }
stepCamera?.addEventListener('click', ()=>switchTab(1)); stepExtract?.addEventListener('click', ()=>switchTab(2)); stepROI?.addEventListener('click', ()=>switchTab(3)); stepAnalyzeBtn?.addEventListener('click', ()=>switchTab(4));
function getFpsValue(){ return Math.max(1, numOr(fpsInput?.value, 10)); }
function getConfValue(){ const v=numOr(confInput?.value,0.3); return Math.max(0, Math.min(1, v)); }
function getScaleValue(){ const v=numOr(scaleInput?.value, 100); scalePxPerUnit=Math.max(0.0001, v); return scalePxPerUnit; }
function resizeOverlay(){ if(!overlay||!video) return; const dpr=window.devicePixelRatio||1; const w=Math.max(1, Math.round(video.clientWidth*dpr)); const h=Math.max(1, Math.round(video.clientHeight*dpr)); overlay.width=w; overlay.height=h; overlay.style.width=video.clientWidth+'px'; overlay.style.height=video.clientHeight+'px'; }
window.addEventListener('resize', resizeOverlay); video?.addEventListener('loadedmetadata', ()=>{ resizeOverlay(); });
if(videoFile){ videoFile.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f){ userLog('파일 선택 취소'); return; } const url=URL.createObjectURL(f); video.srcObject=null; video.src=url; video.style.display='block'; video.playsInline=true; video.muted=false; video.controls=true; await new Promise(res=>{ const t=setTimeout(()=>{res();},3000); function onMeta(){ clearTimeout(t); video.removeEventListener('loadedmetadata', onMeta); res(); } video.addEventListener('loadedmetadata', onMeta, {once:true}); }); try{ await video.play(); }catch{} extractFramesBtn && (extractFramesBtn.disabled=false); switchTab(2); }); }
let currentStream=null, mediaRecorder=null, recordedChunks=[], extractedFrames=[], currentFrameIndex=0;
if(startCameraBtn){ startCameraBtn.addEventListener('click', async ()=>{ try{ const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false}); currentStream=s; video.srcObject=s; video.muted=true; video.playsInline=true; video.controls=false; await video.play().catch(()=>{}); recordToggleBtn && (recordToggleBtn.style.display='', recordToggleBtn.disabled=false); }catch(err){ alert('카메라 접근 실패: '+err.message); } }); }
if(recordToggleBtn){ recordToggleBtn.addEventListener('click', ()=>{ if(!currentStream) return; if(!mediaRecorder || mediaRecorder.state==='inactive'){ recordedChunks=[]; mediaRecorder=new MediaRecorder(currentStream); mediaRecorder.ondataavailable=(e)=>{ if(e.data&&e.data.size) recordedChunks.push(e.data); }; mediaRecorder.onstop=()=>{ const blob=new Blob(recordedChunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); video.srcObject=null; video.src=url; video.muted=false; video.play().catch(()=>{}); extractFramesBtn && (extractFramesBtn.disabled=false); }; mediaRecorder.start(); recordToggleBtn.textContent='녹화 중지'; } else { mediaRecorder.stop(); recordToggleBtn.textContent='녹화 시작'; } }); }
let isExtracting=false; function setProgress(p){ if(progressBar) progressBar.style.width=`${p}%`; if(progressText) progressText.textContent=`${p}%`; }
async function extractFrames(){ if(isExtracting) return; if(!video||(!video.currentSrc && !video.src)) return; const srcUrl=video.currentSrc||video.src; isExtracting=true; extractedFrames=[]; currentFrameIndex=0; extractProgress && (extractProgress.style.display=''); setProgress(0); try{ const cap=document.createElement('video'); cap.muted=true; cap.preload='auto'; cap.crossOrigin='anonymous'; cap.src=srcUrl; await new Promise(res=>{ const to=setTimeout(()=>{res();},4000); cap.addEventListener('loadedmetadata',()=>{ clearTimeout(to); res(); },{once:true}); }); const fps=Math.max(1, numOr(fpsInput?.value,10)); const duration=cap.duration||video.duration||0; const total=Math.max(1, Math.floor(duration*fps)); const dpr=window.devicePixelRatio||1; const cssW=cap.videoWidth||640; const cssH=cap.videoHeight||360; for(let i=0;i<total;i++){ const t=Math.min(duration, (i/fps)); await new Promise(res=>{ let done=false; function onSeek(){ if(done) return; done=true; cap.removeEventListener('seeked', onSeek); res(); } cap.currentTime=t; cap.addEventListener('seeked', onSeek); setTimeout(()=>{ if(!done){ done=true; cap.removeEventListener('seeked', onSeek); res(); } },1200); }); const c=document.createElement('canvas'); c._cssWidth=cssW; c._cssHeight=cssH; c._dpr=dpr; c.width=Math.round(cssW*dpr); c.height=Math.round(cssH*dpr); const ctx=c.getContext('2d'); try{ ctx.setTransform(dpr,0,0,dpr,0,0); ctx.drawImage(cap,0,0,cssW,cssH); }catch{ ctx.fillStyle='#333'; ctx.fillRect(0,0,cssW,cssH); } extractedFrames.push(c); const percent=Math.round(((i+1)/total)*100); setProgress(percent); } extractProgress && (extractProgress.style.display='none'); setProgress(100); await showFrame(0); document.querySelectorAll('.frame-nav').forEach(el=>el.style.display='flex'); }catch(err){ console.warn('extract error',err); } finally{ isExtracting=false; extractFramesBtn && (extractFramesBtn.disabled=false); } }
extractFramesBtn?.addEventListener('click', ()=>{ extractFramesBtn.disabled=true; extractFrames(); });
async function showFrame(idx){ if(!extractedFrames||!extractedFrames.length) return; currentFrameIndex=Math.max(0, Math.min(idx, extractedFrames.length-1)); const c=extractedFrames[currentFrameIndex]; await new Promise(r=>requestAnimationFrame(r)); const displayW=framePreview?.clientWidth||video.clientWidth||overlay.clientWidth||640; const displayH=framePreview?.clientHeight||video.clientHeight||overlay.clientHeight||360; const dpr=window.devicePixelRatio||1; overlay.width=Math.max(1, Math.round(displayW*dpr)); overlay.height=Math.max(1, Math.round(displayH*dpr)); overlay.style.width=displayW+'px'; overlay.style.height=displayH+'px'; const ctx=overlay.getContext('2d'); try{ ctx.setTransform(1,0,0,1,0,0); }catch{} ctx.clearRect(0,0,overlay.width,overlay.height); ctx.setTransform(dpr,0,0,dpr,0,0); try{ ctx.drawImage(c,0,0,c.width,c.height,0,0,displayW,displayH); }catch(e){} try{ framePreview.src=c.toDataURL('image/png'); framePreview.style.width=displayW+'px'; framePreview.style.height=displayH+'px'; framePreview.style.objectFit='contain'; framePreview.style.display=''; framePreview.style.visibility='visible'; overlay.style.visibility='visible'; }catch{} frameIdxEl && (frameIdxEl.textContent = `Frame ${currentFrameIndex+1} / ${extractedFrames.length}`); const roiObj=frameROIs[currentFrameIndex]; if(roiObj){ const srcCssW=c._cssWidth||Math.round((c.width||displayW)/dpr); const srcCssH=c._cssHeight||Math.round((c.height||displayH)/dpr); const scaleX=displayW/(srcCssW||displayW); const scaleY=displayH/(srcCssH||displayH); ctx.strokeStyle='#00ff88'; ctx.lineWidth=2; ctx.setLineDash([6,4]); ctx.strokeRect(roiObj.x*scaleX, roiObj.y*scaleY, roiObj.w*scaleX, roiObj.h*scaleY); ctx.setLineDash([]); } }
function bindMulti(el, handler, cooldownMs){ if(!el) return; let last=0; const wrapper=function(e){ const now=Date.now(); if(cooldownMs && now-last<cooldownMs) return; last=now; try{ handler(e); }catch(err){ console.warn('bindMulti error',err); } }; el.addEventListener('click', wrapper); el.addEventListener('pointerdown', wrapper); }
if(prevFrameBtn){ bindMulti(prevFrameBtn,(e)=>{ e?.preventDefault?.(); e?.stopPropagation?.(); if(!extractedFrames?.length) return; const now=Date.now(); if(now-lastNavTime<250) return; lastNavTime=now; showFrame(Math.max(0, currentFrameIndex-1)); },300); }
if(nextFrameBtn){ bindMulti(nextFrameBtn,(e)=>{ e?.preventDefault?.(); e?.stopPropagation?.(); if(!extractedFrames?.length) return; const now=Date.now(); if(now-lastNavTime<250) return; lastNavTime=now; showFrame(Math.min(extractedFrames.length-1, currentFrameIndex+1)); },300); }
let isDrawingROI=false, startX=0, startY=0;
function drawOverlay(){ const dpr=window.devicePixelRatio||1; const ctx=overlay.getContext('2d'); try{ ctx.setTransform(1,0,0,1,0,0); }catch{} ctx.clearRect(0,0,overlay.width,overlay.height); ctx.setTransform(dpr,0,0,dpr,0,0); if(extractedFrames?.length){ const c=extractedFrames[currentFrameIndex]; const displayW=overlay.clientWidth, displayH=overlay.clientHeight; try{ ctx.drawImage(c,0,0,c.width,c.height,0,0,displayW,displayH); }catch{} } if(roi){ ctx.strokeStyle='#00ff88'; ctx.lineWidth=2; ctx.setLineDash([6,4]); ctx.strokeRect(roi.x, roi.y, roi.w, roi.h); ctx.setLineDash([]); } const last=detectionsPerFrame.length ? detectionsPerFrame[currentFrameIndex] : null; if(last?.box){ const [x1,y1,x2,y2]=last.box; const c=extractedFrames[currentFrameIndex]; const srcCssW=c?(c._cssWidth||overlay.clientWidth):overlay.clientWidth; const srcCssH=c?(c._cssHeight||overlay.clientHeight):overlay.clientHeight; const scaleX=overlay.clientWidth/srcCssW; const scaleY=overlay.clientHeight/srcCssH; ctx.strokeStyle='#ff0066'; ctx.lineWidth=3; ctx.strokeRect(x1*scaleX, y1*scaleY, (x2-x1)*scaleX, (y2-y1)*scaleY); } }
function overlayToCanvasRect(ov){ const c=extractedFrames[currentFrameIndex]; const dpr=window.devicePixelRatio||1; const srcCssW=c?(c._cssWidth||Math.round((c.width||overlay.clientWidth)/dpr)):overlay.clientWidth; const srcCssH=c?(c._cssHeight||Math.round((c.height||overlay.clientHeight)/dpr)):overlay.clientHeight; const sx=srcCssW/overlay.clientWidth; const sy=srcCssH/overlay.clientHeight; return { x:ov.x*sx, y:ov.y*sy, w:ov.w*sx, h:ov.h*sy }; }
overlay.addEventListener('pointerdown', (e)=>{ const r=overlay.getBoundingClientRect(); startX=e.clientX-r.left; startY=e.clientY-r.top; roi={x:startX,y:startY,w:0,h:0}; isDrawingROI=true; drawOverlay(); });
overlay.addEventListener('pointermove', (e)=>{ if(!isDrawingROI||!roi) return; const r=overlay.getBoundingClientRect(); const x=e.clientX-r.left; const y=e.clientY-r.top; roi.w=x-roi.x; roi.h=y-roi.y; if(roi.w<0){ roi.x=x; roi.w=Math.abs(roi.w); } if(roi.h<0){ roi.y=y; roi.h=Math.abs(roi.h); } drawOverlay(); });
overlay.addEventListener('pointerup', ()=>{ if(!isDrawingROI||!roi) return; isDrawingROI=false; const canvasROI=overlayToCanvasRect(roi); frameROIs[currentFrameIndex]=canvasROI; });
function mapBoxToOverlay(box){ const vw=video.videoWidth, vh=video.videoHeight; if(!vw||!vh) return [0,0,0,0]; const videoRect=video.getBoundingClientRect(); const scaleX=videoRect.width/vw; const scaleY=videoRect.height/vh; const [x1,y1,x2,y2]=box; return [x1*scaleX,y1*scaleY,x2*scaleX,y2*scaleY]; }
async function loadModel(){ const candidate=['./yolov8n.onnx','./model/yolov8n.onnx']; const opts={executionProviders:['wasm','webgl']}; const statusEl=$('status'); if(statusEl) statusEl.textContent='모델 로드 상태: 로딩 시도 중...'; let lastErr=null; for(const p of candidate){ try{ const resp=await fetch(p,{method:'GET'}); if(!resp.ok){ lastErr=new Error('HTTP '+resp.status); continue; } const ab=await resp.arrayBuffer(); modelSession=await ort.InferenceSession.create(ab,opts); modelLoaded=true; statusEl && (statusEl.textContent=`모델 로드 상태: 성공 (${p})`); return; }catch(err){ lastErr=err; } } modelLoaded=false; statusEl && (statusEl.innerHTML='모델 로드 상태: 실패 — <code>yolov8n.onnx</code> 파일을 루트 또는 <code>./model/</code>에 두세요.'); }
loadModel();
let playTimer=null; function playResults(){ if(!extractedFrames?.length) return; let idx=0; const total=extractedFrames.length; const fps=getFpsValue(); if(playTimer) clearInterval(playTimer); playTimer=setInterval(()=>{ const c=extractedFrames[idx]; const displayW=overlay.clientWidth||video.clientWidth||640; const displayH=overlay.clientHeight||video.clientHeight||360; const dpr=window.devicePixelRatio||1; overlay.width=Math.max(1,Math.round(displayW*dpr)); overlay.height=Math.max(1,Math.round(displayH*dpr)); overlay.style.width=displayW+'px'; overlay.style.height=displayH+'px'; const ctx=overlay.getContext('2d'); try{ ctx.setTransform(1,0,0,1,0,0); }catch{} ctx.clearRect(0,0,overlay.width,overlay.height); ctx.setTransform(dpr,0,0,dpr,0,0); try{ ctx.drawImage(c,0,0,c.width,c.height,0,0,displayW,displayH); }catch{} const det=detectionsPerFrame[idx]; if(det?.box){ const srcCssW=c._cssWidth||Math.round((c.width||displayW)/dpr); const srcCssH=c._cssHeight||Math.round((c.height||displayH)/dpr); const scaleX=displayW/(srcCssW||displayW); const scaleY=displayH/(srcCssH||displayH); const [x1,y1,x2,y2]=det.box; ctx.strokeStyle='#ff0066'; ctx.lineWidth=3; ctx.strokeRect(x1*scaleX,y1*scaleY,(x2-x1)*scaleX,(y2-y1)*scaleY); } idx++; if(idx>=total) idx=0; }, 1000/fps); }
async function analyzeWithYOLO(){ if(!modelLoaded){ alert('모델이 로드되어 있지 않습니다.'); return; } detectionsPerFrame=[]; const fps=getFpsValue(); const duration=video.duration||0; const totalFrames=Math.floor(duration*fps); const confTh=getConfValue(); video.pause(); for(let i=0;i<totalFrames;i++){ const t=i/fps; await seekToTime(t); const img=captureFrameImage(); const {tensor,padInfo}=preprocessForYOLO(img,640); const inputName=modelSession.inputNames[0]; const feeds={}; feeds[inputName]=tensor; let output=null; try{ const res=await modelSession.run(feeds); const outName=modelSession.outputNames[0]; output=res[outName]; }catch(err){ alert('모델 실행 실패'); return; } const dets=parseYoloOutput(output,padInfo,confTh); let chosen=null; const roiHere=frameROIs[i]; if(roiHere && dets.length){ const vroi=[roiHere.x,roiHere.y,roiHere.x+roiHere.w,roiHere.y+roiHere.h]; let best=0; for(const d of dets){ const iou=boxIoU(d.box, vroi); if(iou>best){ best=iou; chosen=d; } } if(best<0.05) chosen=dets[0]; } else if(dets.length){ chosen=dets[0]; } if(chosen) detectionsPerFrame.push({time:video.currentTime, box:chosen.box, score:chosen.score}); else detectionsPerFrame.push({time:video.currentTime, box:null, score:0}); if(i%10===0) drawOverlay(); } analyzeTrackData(); }
function captureFrameImage(videoEl){ const src=videoEl||video; const tmp=document.createElement('canvas'); const cssW=(src && src.videoWidth) || Math.max(320, (src && src.clientWidth) || 320); const cssH=(src && src.videoHeight) || Math.max(240, (src && src.clientHeight) || 240); const dpr=window.devicePixelRatio||1; tmp.width=Math.max(1, Math.round(cssW*dpr)); tmp.height=Math.max(1, Math.round(cssH*dpr)); tmp.style.width=cssW+'px'; tmp.style.height=cssH+'px'; tmp._cssWidth=cssW; tmp._cssHeight=cssH; tmp._dpr=dpr; const tctx=tmp.getContext('2d'); try{ tctx.setTransform(dpr,0,0,dpr,0,0); tctx.drawImage(src,0,0,cssW,cssH); }catch(err){ tctx.setTransform(1,0,0,1,0,0); tctx.fillStyle='rgb(100,100,100)'; tctx.fillRect(0,0,tmp.width,tmp.height); } return tmp; }
function preprocessForYOLO(canvas, size){ const iw=canvas.width, ih=canvas.height; const scale=Math.min(size/iw, size/ih); const nw=Math.round(iw*scale), nh=Math.round(ih*scale); const dx=Math.floor((size-nw)/2), dy=Math.floor((size-nh)/2); const tmp=document.createElement('canvas'); tmp.width=size; tmp.height=size; const ctx=tmp.getContext('2d'); ctx.fillStyle='rgb(114,114,114)'; ctx.fillRect(0,0,size,size); ctx.drawImage(canvas,0,0,iw,ih, dx,dy, nw,nh); const id=ctx.getImageData(0,0,size,size).data; const f32=new Float32Array(1*3*size*size); for(let y=0;y<size;y++){ for(let x=0;x<size;x++){ const i=(y*size+x)*4; const r=id[i]/255, g=id[i+1]/255, b=id[i+2]/255; const idx=y*size+x; f32[idx]=r; f32[size*size+idx]=g; f32[2*size*size+idx]=b; } } const tensor=new ort.Tensor('float32', f32, [1,3,size,size]); return {tensor, padInfo:{dx,dy,scale}}; }
function parseYoloOutput(outputTensor, padInfo, confThreshold){ const results=[]; if(!outputTensor) return results; const data=outputTensor.data; const shape=outputTensor.dims||[]; let N=0,C=0,row=0; if(shape.length===3 && shape[0]===1){ N=shape[1]; C=shape[2]; row=C; } else if(shape.length===2){ N=shape[0]; C=shape[1]; row=C; } else { return results; } for(let i=0;i<N;i++){ const base=i*row; if(base+Math.min(6,C)>data.length) break; const cx=data[base+0], cy=data[base+1], w=data[base+2], h=data[base+3]; const obj=(C>4)?data[base+4]:1.0; let maxp=1.0; if(C>5){ maxp=0; for(let c=5;c<C;c++){ const p=data[base+c]; if(p>maxp) maxp=p; } } const score=obj*maxp; if(score<confThreshold) continue; const x1=(cx-w/2-padInfo.dx)/padInfo.scale; const y1=(cy-h/2-padInfo.dy)/padInfo.scale; const x2=(cx+w/2-padInfo.dx)/padInfo.scale; const y2=(cy+h/2-padInfo.dy)/padInfo.scale; results.push({box:[x1,y1,x2,y2], score}); } results.sort((a,b)=>b.score-a.score); return nms(results, 0.45); }
function nms(boxes, iou){ const out=[]; for(const b of boxes){ let keep=true; for(const o of out){ if(boxIoU(o.box,b.box)>iou){ keep=false; break; } } if(keep) out.push(b); } return out; }
function boxIoU(a,b){ if(!a||!b) return 0; const [ax1,ay1,ax2,ay2]=a, [bx1,by1,bx2,by2]=b; const ix1=Math.max(ax1,bx1), iy1=Math.max(ay1,by1); const ix2=Math.min(ax2,bx2), iy2=Math.min(ay2,by2); const iw=Math.max(0, ix2-ix1), ih=Math.max(0, iy2-iy1); const inter=iw*ih; const aarea=Math.max(0,ax2-ax1)*Math.max(0,ay2-ay1); const barea=Math.max(0,bx2-bx1)*Math.max(0,by2-by1); return inter/(aarea+barea-inter+1e-6); }
function seekToTime(t, videoEl){ const src=videoEl||video; return new Promise((res)=>{ let done=false; const clear=()=>{ try{ src.removeEventListener('seeked',onseek); src.removeEventListener('timeupdate',ontime); }catch{} }; const onseek=()=>{ if(done) return; done=true; clearTimeout(timer); clear(); res(); }; const ontime=()=>{ if(done) return; done=true; clearTimeout(timer); clear(); res(); }; src.addEventListener('seeked', onseek); src.addEventListener('timeupdate', ontime); try{ src.currentTime=Math.min(src.duration||t, t); }catch{} const timer=setTimeout(()=>{ if(!done){ done=true; clear(); res(); } }, 3000); }); }
function analyzeTrackData(){ const points=[]; for(const f of detectionsPerFrame){ if(f.box){ const [x1,y1,x2,y2]=f.box; const cx=(x1+x2)/2, cy=(y1+y2)/2; points.push({t:f.time, x:cx, y:cy}); } else { points.push({t:f.time, x:null, y:null}); } } const speeds=[], accs=[]; for(let i=0;i<points.length;i++){ if(i===0){ speeds.push(null); accs.push(null); continue; } const p0=points[i-1], p1=points[i]; if(p0.x==null||p1.x==null){ speeds.push(null); accs.push(null); continue; } const dt=p1.t-p0.t || (1/getFpsValue()); const distPx=Math.hypot(p1.x-p0.x, p1.y-p0.y); const speed=(distPx/dt)/getScaleValue(); speeds.push(speed); if(i===1){ accs.push(null); continue; } const prev=speeds[i-1]||0; const acc=(speed-prev)/dt; accs.push(acc); }
  // Chart.js가 없으면 그래프 생략 (초보 배포 안정성)
  if(typeof Chart==='undefined'){ console.warn('Chart.js 미로드: 그래프 생략'); return; }
  const labels=points.map(p=>p.t.toFixed(2)); const xs=points.map(p=>p.x!=null?(p.x/getScaleValue()):null); const ys=points.map(p=>p.y!=null?(p.y/getScaleValue()):null); const speedData=speeds.map(s=>s||0);
  if(posChart) posChart.destroy(); const posCtx=document.getElementById('posChart').getContext('2d'); posChart=new Chart(posCtx,{ type:'line', data:{labels, datasets:[{label:'X (단위)', data:xs, borderColor:'#4fd1c5', tension:0.2, spanGaps:true},{label:'Y (단위)', data:ys, borderColor:'#f97316', tension:0.2, spanGaps:true}]}, options:{responsive:true, maintainAspectRatio:false} });
  if(velChart) velChart.destroy(); const velCtx=document.getElementById('velChart').getContext('2d'); velChart=new Chart(velCtx,{ type:'line', data:{labels, datasets:[{label:'Speed (단위/초)', data:speedData, borderColor:'#60a5fa', tension:0.2, spanGaps:true}]}, options:{responsive:true, maintainAspectRatio:false} });
}
if(exportCSVBtn){ bindMulti(exportCSVBtn,(e)=>{ e?.preventDefault?.(); if(!detectionsPerFrame?.length){ alert('분석 후 내보내기 하세요.'); return; } const rows=[["frame","time_s","x_px","y_px","x_unit","y_unit","speed_unit_s","acc_unit_s2"]]; for(let i=0;i<detectionsPerFrame.length;i++){ const d=detectionsPerFrame[i]; const t=(d.time||0).toFixed(4); rows.push([i, t, '', '', '', '', '', '']); } const csv=rows.map(r=>r.join(',')).join(''); const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='analysis.csv'; a.click(); URL.revokeObjectURL(url); }); }
if(runDetectBtn) bindMulti(runDetectBtn, async (e)=>{ e?.preventDefault?.(); await analyzeWithYOLO(); });
setInterval(()=>{ drawOverlay(); }, 500);

  </script>
</body>
</html>
