<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Motion Tracker (YOLO ONNX)</title>

  <style>
    :root{ --bg:#0f1724; --card:#0b1220; --accent:#0ea5ff; --text:#e6eef8; }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif; background:linear-gradient(180deg,#071024,#0b1522); color:var(--text); }
    .app{ max-width:1100px; margin:12px auto; padding:12px; }
    header h1{ margin:0; font-size:1.4rem; }
    .subtitle{ margin:4px 0 12px; color:#bcd7f7; }

    .controls{ background:rgba(255,255,255,0.03); padding:10px; border-radius:10px; margin-bottom:12px; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; }
    .row.small{ margin-top:8px; font-size:0.9rem; }
    .file-btn{ background:var(--card); padding:8px 10px; border-radius:8px; cursor:pointer; }
    .file-btn input{ display:none; }
    button{ background:var(--accent); border:0; color:#04233a; padding:8px 10px; border-radius:8px; cursor:pointer; }

    .workspace{ display:flex; gap:12px; align-items:flex-start; }
    .video-wrap{
      position:relative; flex:1; min-width:260px;
      border-radius:8px; overflow:hidden; background:#000;
      aspect-ratio:16/9; min-height:240px; max-height:70vh;
    }
    .video-wrap > video, .video-wrap > img, .video-wrap > canvas{
      position:absolute; left:0; top:0; width:100%; height:100%; display:block;
    }
    video{ width:100%; height:100%; display:block; z-index:1; }
    img#framePreview{ z-index:2; pointer-events:none; object-fit:contain; }
    canvas#overlay{ position:absolute; left:0; top:0; touch-action:none; z-index:3; pointer-events:auto; }

    /* 초기: 프리뷰/오버레이 숨김 */
    #framePreview, #overlay{ display:none; visibility:hidden; }

    .analysis{ width:320px; background:rgba(255,255,255,0.03); padding:10px; border-radius:8px; }
    #charts canvas{ width:100% !important; height:200px; }
    footer{ margin-top:12px; color:#9fb7d9; }
    @media (max-width:800px){ .workspace{ flex-direction:column; } .analysis{ width:100%; } }
    .hint{ font-size:0.9rem; color:#a9c6e9; }

    .tabs{ display:flex; gap:6px; margin-bottom:10px; }
    .tab{ background:rgba(255,255,255,0.03); padding:8px 10px; border-radius:8px; cursor:pointer; }
    .tab.active{ background:linear-gradient(90deg,#06b6d4,#4fd1c5); color:#002733; }
    .tab-content{ padding:8px; background:rgba(255,255,255,0.02); border-radius:8px; }
    .big{ background:#06b6d4; color:#002733; padding:10px 12px; border-radius:8px; font-weight:600; }
    .frame-nav button{ padding:6px 10px; }
  </style>

  https://cdn.jsdelivr.net/npm/chart.js</script>
  https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js</script>
</head>
<body>
  <div class="app">
    <header>
      <h1>Motion Tracker (YOLO ONNX)</h1>
      <div class="subtitle">동영상에서 물체를 지정해 운동을 분석합니다. (모바일 지원)</div>
      <div id="status">모델 로드 상태: 대기 중...</div>

      <div class="tabs">
        <button id="stepCamera" class="tab active">촬영/업로드</button>
        <button id="stepExtract" class="tab">프레임 추출</button>
        <button id="stepROI" class="tab">ROI 선택</button>
        <button id="stepAnalyze" class="tab">분석/결과</button>
      </div>
    </header>

    <section id="tab-1" class="tab-content">
      <div class="controls">
        <div class="row">
          <label class="file-btn">
            <input type="file" id="videoFile" accept="video/*" />
            비디오 업로드
          </label>
          <button id="startCamera">카메라 켜기</button>
          <button id="recordToggle" style="display:none;" disabled>녹화 시작</button>
        </div>
        <div class="hint">카메라로 촬영하거나 비디오 파일을 업로드하세요.</div>
      </div>

      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>

        <aside class="analysis">
          <div class="big">스케일(픽셀→단위)</div>
          <div class="row small">
            <label>픽셀/단위: <input id="scaleInput" type="number" min="0.0001" step="0.0001" value="100" /></label>
          </div>
          <div id="charts">
            <canvas id="posChart"></canvas>
            <canvas id="velChart"></canvas>
          </div>
        </aside>
      </div>
    </section>

    <section id="tab-2" class="tab-content" style="display:none;">
      <div class="controls">
        <div class="row">
          <label>FPS: <input id="fpsInput" type="number" min="1" step="1" value="10" /></label>
          <button id="extractFramesBtn" disabled>프레임 추출 시작</button>
        </div>
        <div id="extractProgress" class="row small" style="display:none;">
          <div style="flex:1;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;">
            <div id="progressBar" style="width:0%;height:8px;background:#0ea5ff;"></div>
          </div>
          <div id="progressText">0%</div>
        </div>
        <div class="frame-nav" style="display:none;gap:8px;align-items:center;margin-top:8px;">
          <button id="prevFrame">◀</button>
          <span id="frameIdx">Frame 0 / 0</span>
          <button id="nextFrame">▶</button>
        </div>
        <div class="hint">추출된 프레임은 상단 영상 영역에 이미지로 표시됩니다.</div>
      </div>

      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>
        <aside class="analysis">
          <div class="hint">프레임을 확인하고 다음 탭에서 ROI를 지정하세요.</div>
        </aside>
      </div>
    </section>

    <section id="tab-3" class="tab-content" style="display:none;">
      <div class="controls">
        <div class="big">이 프레임 ROI 선택</div>
        <div class="hint">오버레이 캔버스에서 드래그하여 ROI(관심 영역)를 그리면 자동 저장됩니다. 프레임별로 반복하세요.</div>
        <div class="row">
          <button id="completeROIs">ROI 선택 완료 (자동 분석 실행)</button>
        </div>
      </div>

      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>
        <aside class="analysis">
          <div class="hint">ROI가 있는 프레임은 해당 영역을, 없는 프레임은 YOLO로 자동 지정됩니다.</div>
        </aside>
      </div>
    </section>

    <section id="tab-4" class="tab-content" style="display:none;">
      <div class="controls">
        <div class="row">
          <label>신뢰도(0~1): <input id="confInput" type="number" min="0" max="1" step="0.01" value="0.3" /></label>
          <button id="runDetectBtn">자동 분석</button>
          <button id="playResultsBtn">결과 재생</button>
          <button id="exportCSV">CSV 내보내기</button>
        </div>
        <div class="hint">분석을 실행하면 그래프가 갱신되고 오버레이에 박스가 그려집니다.</div>
      </div>

      <div class="workspace">
        <div class="video-wrap">
          <video playsinline muted></video>
          <img id="framePreview" alt="frame preview" />
          <canvas id="overlay"></canvas>
        </div>
        <aside class="analysis">
          <div id="charts">
            <canvas id="posChart"></canvas>
            <canvas id="velChart"></canvas>
          </div>
        </aside>
      </div>
    </section>

    <footer>모델 파일(<code>yolov8n.onnx</code>)을 프로젝트 루트 또는 <code>./model/</code>에 두세요.</footer>
  </div>

  <script>
    const $ = id => document.getElementById(id);
    const video = document.querySelector('.video-wrap > video');
    const overlay = $('overlay');
    const framePreview = $('framePreview');

    let modelSession=null, modelLoaded=false, detectionsPerFrame=[], frameROIs=[], roi=null;
    let posChart=null, velChart=null, scalePxPerUnit=100, lastNavTime=0, isExtracting=false;

    const numOr = (v, def) => { const n = Number(v); return Number.isFinite(n) ? n : def; };

    const videoFile=$('videoFile'), startCameraBtn=$('startCamera'), recordToggleBtn=$('recordToggle'), extractFramesBtn=$('extractFramesBtn');
    const prevFrameBtn=$('prevFrame'), nextFrameBtn=$('nextFrame'), frameIdxEl=$('frameIdx'), extractProgress=$('extractProgress'), progressBar=$('progressBar'), progressText=$('progressText');
    const stepCamera=$('stepCamera'), stepExtract=$('stepExtract'), stepROI=$('stepROI'), stepAnalyzeBtn=$('stepAnalyze');
    const runDetectBtn=$('runDetectBtn'), completeROIsBtn=$('completeROIs'), playResultsBtn=$('playResultsBtn'), exportCSVBtn=$('exportCSV');
    const fpsInput=$('fpsInput'), confInput=$('confInput'), scaleInput=$('scaleInput');

    function switchTab(n){ [1,2,3,4].forEach(i=>{ const panel=$('tab-'+i); const btn=document.getElementById('step'+(i===1?'Camera':(i===2?'Extract':(i===3?'ROI':'Analyze')))); if(panel) panel.style.display=(i===n)?'':'none'; if(btn){ if(i===n) btn.classList.add('active'); else btn.classList.remove('active'); } }); }
    stepCamera?.addEventListener('click', ()=>switchTab(1));
    stepExtract?.addEventListener('click', ()=>switchTab(2));
    stepROI?.addEventListener('click', ()=>switchTab(3));
    stepAnalyzeBtn?.addEventListener('click', ()=>switchTab(4));

    function getFpsValue(){ return Math.max(1, numOr(fpsInput?.value, 10)); }
    function getConfValue(){ const v=numOr(confInput?.value, 0.3); return Math.max(0, Math.min(1, v)); }
    function getScaleValue(){ const v=numOr(scaleInput?.value, 100); scalePxPerUnit = Math.max(0.0001, v); return scalePxPerUnit; }

    function resizeOverlay(){
      if(!overlay || !video) return;
      const dpr = window.devicePixelRatio || 1;
      const w = Math.max(1, Math.round(video.clientWidth * dpr));
      const h = Math.max(1, Math.round(video.clientHeight * dpr));
      overlay.width = w; overlay.height = h;
      overlay.style.width = video.clientWidth + 'px';
      overlay.style.height = video.clientHeight + 'px';
    }
    window.addEventListener('resize', resizeOverlay);
    video?.addEventListener('loadedmetadata', resizeOverlay);

    if(videoFile){
      videoFile.addEventListener('change', async (e)=>{
        const f = e.target.files?.[0];
        if(!f) return;
        const url = URL.createObjectURL(f);

        framePreview.style.display = 'none';
        framePreview.style.visibility = 'hidden';
        overlay.style.display = 'none';
        overlay.style.visibility = 'hidden';

        video.srcObject = null;
        video.src = url;
        video.style.display = 'block';
        video.style.visibility = 'visible';
        video.controls = true;
        video.muted = false;
        video.playsInline = true;

        await new Promise(res=>{
          const t = setTimeout(res, 3000);
          function onMeta(){ clearTimeout(t); video.removeEventListener('loadedmetadata', onMeta); res(); }
          video.addEventListener('loadedmetadata', onMeta, {once:true});
        });
        video.play().catch(()=>{});

        extractFramesBtn && (extractFramesBtn.disabled = false);
        switchTab(2);
      });
    }

    let currentStream=null, mediaRecorder=null, recordedChunks=[];
    if(startCameraBtn){
      startCameraBtn.addEventListener('click', async ()=>{
        try{
          const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
          currentStream = s;
          video.srcObject = s; video.muted = true;
          video.playsInline = true; video.controls = false;
          await video.play().catch(()=>{});
          recordToggleBtn && (recordToggleBtn.style.display='', recordToggleBtn.disabled=false);
        }catch(err){ alert('카메라 접근 실패: '+err.message); }
      });
    }
    if(recordToggleBtn){
      recordToggleBtn.addEventListener('click', ()=>{
        if(!currentStream) return;
        if(!mediaRecorder || mediaRecorder.state === 'inactive'){
          recordedChunks = [];
          mediaRecorder = new MediaRecorder(currentStream);
          mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size) recordedChunks.push(e.data); };
          mediaRecorder.onstop = ()=>{
            const blob = new Blob(recordedChunks, {type:'video/webm'});
            const url = URL.createObjectURL(blob);
            video.srcObject = null; video.src = url; video.muted = false;
            video.play().catch(()=>{});
            extractFramesBtn && (extractFramesBtn.disabled = false);
          };
          mediaRecorder.start(); recordToggleBtn.textContent = '녹화 중지';
        } else {
          mediaRecorder.stop(); recordToggleBtn.textContent = '녹화 시작';
        }
      });
    }

    let isExtracting = false;
    function setProgress(p){ if(progressBar) progressBar.style.width = `${p}%`; if(progressText) progressText.textContent = `${p}%`; }

    async function extractFrames(){
      if(isExtracting) return;
      if(!video || (!video.currentSrc && !video.src)) return;
      const srcUrl = video.currentSrc || video.src;

      isExtracting = true; extractedFrames = []; currentFrameIndex = 0;
      extractProgress && (extractProgress.style.display='');
      setProgress(0);
      try{
        const cap = document.createElement('video');
        cap.muted = true; cap.preload='auto'; cap.crossOrigin='anonymous';
        cap.src = srcUrl;

        await new Promise(res=>{
          const to=setTimeout(()=>{res();},4000);
          cap.addEventListener('loadedmetadata',()=>{ clearTimeout(to); res(); },{once:true});
        });

        const fps = getFpsValue();
        const duration = cap.duration || video.duration || 0;
        const total = Math.max(1, Math.floor(duration * fps));

        const dpr = window.devicePixelRatio || 1;
        const cssW = cap.videoWidth || 640;
        const cssH = cap.videoHeight || 360;

        extractedFrames = [];
        for(let i=0;i<total;i++){
          const t = Math.min(duration, i/fps);
          await new Promise(res=>{
            let done=false;
            function onSeek(){ if(done) return; done=true; cap.removeEventListener('seeked', onSeek); res(); }
            cap.currentTime = t;
            cap.addEventListener('seeked', onSeek);
            setTimeout(()=>{ if(!done){ done=true; cap.removeEventListener('seeked', onSeek); res(); } },1200);
          });

          const c = document.createElement('canvas');
          c._cssWidth = cssW; c._cssHeight = cssH; c._dpr = dpr;
          c.width = Math.round(cssW*dpr); c.height = Math.round(cssH*dpr);
          const ctx = c.getContext('2d');
          try{ ctx.setTransform(dpr,0,0,dpr,0,0); ctx.drawImage(cap,0,0,cssW,cssH); }
          catch{ ctx.fillStyle = '#333'; ctx.fillRect(0,0,cssW,cssH); }
          extractedFrames.push(c);

          const percent = Math.round(((i+1)/total)*100);
          setProgress(percent);
        }

        extractProgress && (extractProgress.style.display='none');
        setProgress(100);

        framePreview.style.display = '';
        framePreview.style.visibility = 'visible';
        overlay.style.display = '';
        overlay.style.visibility = 'visible';

        await showFrame(0);
        document.querySelectorAll('.frame-nav').forEach(el=> el.style.display='flex');
      }catch(err){
      }finally{
        isExtracting = false;
        extractFramesBtn && (extractFramesBtn.disabled=false);
      }
    }
    extractFramesBtn?.addEventListener('click', ()=>{ extractFramesBtn.disabled=true; extractFrames(); });

    let extractedFrames=[], currentFrameIndex=0;
    async function showFrame(idx){
      if(!extractedFrames || !extractedFrames.length) return;
      currentFrameIndex = Math.max(0, Math.min(idx, extractedFrames.length-1));
      const c = extractedFrames[currentFrameIndex];

      await new Promise(r=> requestAnimationFrame(r));

      const displayW = framePreview?.clientWidth || video.clientWidth || overlay.clientWidth || 640;
      const displayH = framePreview?.clientHeight || video.clientHeight || overlay.clientHeight || 360;
      const dpr = window.devicePixelRatio || 1;

      overlay.width = Math.max(1, Math.round(displayW*dpr));
      overlay.height = Math.max(1, Math.round(displayH*dpr));
      overlay.style.width = displayW + 'px';
      overlay.style.height = displayH + 'px';

      const ctx = overlay.getContext('2d');
      try{ ctx.setTransform(1,0,0,1,0,0); }catch{}
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      try{ ctx.drawImage(c,0,0,c.width,c.height,0,0,displayW,displayH); }catch{}

      try{
        framePreview.src = c.toDataURL('image/png');
        framePreview.style.width = displayW+'px';
        framePreview.style.height = displayH+'px';
        framePreview.style.objectFit = 'contain';
        framePreview.style.display = '';
        framePreview.style.visibility = 'visible';
        overlay.style.display = '';
        overlay.style.visibility = 'visible';
      }catch{}

      frameIdxEl && (frameIdxEl.textContent = `Frame ${currentFrameIndex+1} / ${extractedFrames.length}`);

      const roiObj = frameROIs[currentFrameIndex];
      if(roiObj){
        const srcCssW = c._cssWidth || Math.round((c.width || displayW)/dpr);
        const srcCssH = c._cssHeight || Math.round((c.height || displayH)/dpr);
        const scaleX = displayW / (srcCssW || displayW);
        const scaleY = displayH / (srcCssH || displayH);
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2; ctx.setLineDash([6,4]);
        ctx.strokeRect(roiObj.x*scaleX, roiObj.y*scaleY, roiObj.w*scaleX, roiObj.h*scaleY);
        ctx.setLineDash([]);
      }
    }

    let isDrawingROI=false, startX=0, startY=0;
    function overlayToCanvasRect(ov){
      const c = extractedFrames[currentFrameIndex];
      const dpr = window.devicePixelRatio || 1;
      const srcCssW = c?(c._cssWidth || Math.round((c.width || overlay.clientWidth)/dpr)) : overlay.clientWidth;
      const srcCssH = c?(c._cssHeight || Math.round((c.height || overlay.clientHeight)/dpr)) : overlay.clientHeight;
      const sx = srcCssW / overlay.clientWidth;
      const sy = srcCssH / overlay.clientHeight;
      return { x: ov.x*sx, y: ov.y*sy, w: ov.w*sx, h: ov.h*sy };
    }
    overlay.addEventListener('pointerdown', (e)=>{
      const r = overlay.getBoundingClientRect();
      startX = e.clientX - r.left;
      startY = e.clientY - r.top;
      roi = { x:startX, y:startY, w:0, h:0 };
      isDrawingROI = true;
    });
    overlay.addEventListener('pointermove', (e)=>{
      if(!isDrawingROI || !roi) return;
      const r = overlay.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;
      roi.w = x - roi.x; roi.h = y - roi.y;
      if(roi.w<0){ roi.x=x; roi.w=Math.abs(roi.w); }
      if(roi.h<0){ roi.y=y; roi.h=Math.abs(roi.h); }
    });
    overlay.addEventListener('pointerup', ()=>{
      if(!isDrawingROI || !roi) return;
      isDrawingROI = false;
      const canvasROI = overlayToCanvasRect(roi);
      frameROIs[currentFrameIndex] = canvasROI;
    });

    async function loadModel(){
      const candidate=['./yolov8n.onnx','./model/yolov8n.onnx'];
      const statusEl = $('status');
      if(statusEl) statusEl.textContent = '모델 로드 상태: 로딩 시도 중...';
      try{
        for(const p of candidate){
          const resp = await fetch(p,{method:'GET'});
          if(!resp.ok) continue;
          const ab = await resp.arrayBuffer();
          modelSession = await ort.InferenceSession.create(ab, {executionProviders:['wasm','webgl']});
          modelLoaded = true;
          statusEl && (statusEl.textContent = `모델 로드 상태: 성공 (${p})`);
          return;
        }
        modelLoaded = false;
        statusEl && (statusEl.innerHTML = '모델 로드 상태: 실패 — yolov8n.onnx를 루트 또는 ./model/에 업로드하세요.');
      }catch(err){
        modelLoaded = false;
        statusEl && (statusEl.innerHTML = '모델 로드 상태: 실패 — 파일/경로 확인');
      }
    }
    loadModel();

    let playTimer = null;
    function playResults(){
      if(!extractedFrames?.length) return;
      let idx = 0; const total = extractedFrames.length; const fps = getFpsValue();
      if(playTimer) clearInterval(playTimer);
      playTimer = setInterval(()=>{
        const c = extractedFrames[idx];
        const displayW = overlay.clientWidth || video.clientWidth || 640;
        const displayH = overlay.clientHeight || video.clientHeight || 360;
        const dpr = window.devicePixelRatio || 1;
        overlay.width = Math.max(1, Math.round(displayW*dpr));
        overlay.height = Math.max(1, Math.round(displayH*dpr));
        overlay.style.width = displayW + 'px';
        overlay.style.height = displayH + 'px';
        const ctx = overlay.getContext('2d');
        try{ ctx.setTransform(1,0,0,1,0,0); }catch{}
        ctx.clearRect(0,0,overlay.width,overlay.height);
        ctx.setTransform(dpr,0,0,dpr,0,0);
        try{ ctx.drawImage(c,0,0,c.width,c.height,0,0,displayW,displayH); }catch(e){}

        const det = detectionsPerFrame[idx];
        if(det?.box){
          const srcCssW = c._cssWidth || Math.round((c.width || displayW)/dpr);
          const srcCssH = c._cssHeight || Math.round((c.height || displayH)/dpr);
          const scaleX = displayW / (srcCssW || displayW);
          const scaleY = displayH / (srcCssH || displayH);
          const [x1,y1,x2,y2] = det.box;
          ctx.strokeStyle='#ff0066'; ctx.lineWidth=3;
          ctx.strokeRect(x1*scaleX, y1*scaleY, (x2-x1)*scaleX, (y2-y1)*scaleY);
        }
        idx++; if(idx>=total) idx=0;
      }, 1000 / fps);
    }
    playResultsBtn?.addEventListener('click', ()=> playResults());

    exportCSVBtn?.addEventListener('click', (e)=>{
      e?.preventDefault?.();
      const rows = [['frame','time_s','x_px','y_px','x_unit','y_unit','speed_unit_s','acc_unit_s2']];
      for(let i=0;i<detectionsPerFrame.length;i++){
        const d = detectionsPerFrame[i];
        const t = (d?.time || 0).toFixed(4);
        rows.push([i, t, '', '', '', '', '', '']);
      }
      const csv = rows.map(r=>r.join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const aTag = document.createElement('a'); aTag.href = url; aTag.download = 'analysis.csv'; aTag.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
